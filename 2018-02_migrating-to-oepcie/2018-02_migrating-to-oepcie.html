<!DOCTYPE html
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="keywords" content="remark,remarkjs,markdown,slideshow,presentation" />
    <meta name="description" content="A simple, in-browser, markdown-driven slideshow tool." />
    <title>Remark</title>
    <style>
      @font-face{
        font-family: 'Droid Serif';
        src: url('./fonts/DroidSerif.ttf');
      }
      @font-face{
        font-family: 'Yanone Kaffeesatz';
        src: url('./fonts/YanoneKaffeesatz-Regular.ttf');
      }
      @font-face{
        font-family: 'Ubuntu Mono';
        src: url('./fonts/UbuntuMono-Regular.ttf');
      }

      /* Colors */
      .red    { color: #FF4943; }
      .gray   { color: #787878; }
	  .lgray   { color: #d9d9d9; }
      .green  { color: #87A558; }
      .blue   { color: #41C8F0; }
      .yellow { color: #DBEC62; }

      html, body { font-family: 'Droid Serif'; }
      img.right { max-width: 100%; display: block; margin-left: auto; margin-right: auto; vertical-align: middle; }
      h1, h2, h3 { font-family: 'Yanone Kaffeesatz'; font-weight: 400; margin-bottom: 0; }
      blockquote { 
        background: #f9f9f9; 
        border-left: 10px solid #ccc; 
        margin: 1.5em 10px; 
        padding: 0.5em 10px; 
        quotes: "\201C""\201D""\2018""\2019"; 
      }
      blockquote p { display: inline; }
      li p { line-height: 1.25em; }
      a, a > code { color: #FF4943; text-decoration: underline; }
      code { background: #FFFFFF; border-radius: 5px; }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote { position: absolute; bottom: 3em; font-size: 0.7em; }
      .small { font-size: 0.8em; }
      .large { font-size: 2em; }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left { float: left; width: 47%; }
      .pull-right { float: right; width: 47%; }
	  .image-middle { display: inline-block; height: 100%; vertical-align: middle; } 
      .pull-right ~ p { clear: both;}
	  .center-small { text-align: center; font-size: 0.7em; }

      #slideshow .slide .content code { font-size: 0.8em; }
      #slideshow .slide .content pre code { font-size: 0.9em; padding: 15px; }

      .inverse { background: #272822; color: #777872; text-shadow: 0 0 20px #333; }
      .inverse h1, .inverse h2 { color: #f3f3f3; line-height: 0.8em; }

      /* Slide-specific styling */
      #slide-inverse .footnote { bottom: 12px; left: 20px; font-size: 0.7em; }
      #slide-how .slides { font-size: 0.9em; position: absolute; top:  151px; right: 140px; }
      #slide-how .slides h3 { margin-top: 0.2em; }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first { background: #fff; position: absolute; top: 20%; left: 20%; z-index: 1; }
      #slide-how .slides .second { position: relative; background: #fff; z-index: 0; }

      /* Two-column layout */
      .left-column { color: #777; width: 20%; height: 92%; float: left; }
      .left-column h2:last-of-type, .left-column h3:last-child { color: #000; }
      .right-column { width: 75%; float: right; padding-top: 1em; }
    </style>
  </head>
  <body>
    <textarea id="source">

name: inverse
layout: true
class: center, middle, inverse
---
##.lgray[Migrating to Open Ephys++<br>]

2018 Feb @ MWL<br> <br>

Jon Newman<br>
[homepage](http://www.mit.edu/~jpnewman/) | [github](https://github.com/jonnew) @jonnew <br>

Project Links<br>
[homepage](https://jonnew.github.io/open-ephys-pcie) | [github](https://github.com/jonnew/open-ephys-pcie)

---
layout: false
.left-column[
  ## Citation Needed
]
.right-column[

    - __Both__ of the following should be included in __any paper or
    presentation__ that makes use of this technology:

    1. Repository Link:
        - Hyperlink footnote .red[<sup>1</sup>] in presentation
        - Parentheical URL in papers (https://github.com/jonnew/open-ephys-pcie)
    2. Paper Citation:
        - 
        - Bioarxiv Paper scheduled for March 2018
        - "Real" paper to follow

.footnote[
  .red[1] https://github.com/jonnew/open-ephys-pcie
]

]

---
template: inverse
##.lgray[Path to Open Ephys ++]

---
layout: false
.left-column[
  ## Multichannel Ephys
  ### Distributed systems (A/D, etc) 
]
.right-column[

### Large, distributed, multichannel A/D conversion

<img class="right" src="./fig/old-ad.png" width="90%"/>

1. Unity gain preamp (1 amp/channel)
2. Analog tether (1 wire/channel)
3. Analog MUX (8 to 1)
3. Amplifier (1 / MUX)
4. Digitizer (1 / MUX)
5. Computer (1 / MUX)

]

---
layout: false
.left-column[
  ## Multichannel Ephys
  ### Distributed systems (A/D, etc) 
]
.right-column[

### Issues
- System has physically large and delecate analog domain
    - Noise easy to pick up
    - Bulky
    - Hard to repair
- A/D conversion using specialized PCB-level systems
    - Bulky
    - Requires sychronization across cards
    - Distributed Clocking etc
- Computational power spread over many PCs
    - Bulky
    - Destroys real-time performance due to networking delays
- Relies on commerical amplifiers, digitizers, etc
    - Expensive
    - Deprecated
]

---

layout: false
.left-column[
  ## Multichannel Ephys
  ### Distributed systems (A/D, etc) 
  ### Intan Chips
]
.right-column[

### _Integrated_ amplification and digitization

<img class="right" src="./fig/intan-block-diagram.png" width="90%"/>

- 16 bit with 10 mV dynamic range
- 0.15 uV / bit (overkill, and not realized in practice)

]

---
layout: false
.left-column[
  ## Multichannel Ephys
  ### Distributed systems (A/D, etc) 
  ### Intan Chips
  ### Open Ephys 
]
.right-column[

### Open Ephys 1.0

<img class="right" src="./fig/oe-summary.jpg" width="90%"/>

- Three main components
    1. Intan chip (headstage)
    2. USB to Intan bridge (Opal Kelly board)
    3. Host computer (Acqusition drivers and software)

]

---
layout: false
.left-column[
  ## Multichannel Ephys
  ### Distributed systems (A/D, etc) 
  ### Intan Chips
  ### Open Ephys 
]
.right-column[

### Open Ephys 1.0: Improvements

.pull-right[
<img class="right" src="./fig/oe-summary.jpg" width="100%"/>
]

.pull-left[
1. Much smaller analog domain
2. Higher resolution A/D conversion in 0.01 - 10 kHz domain
3. Simplified connectorization to acqusition PC
4. Software ease of use and exapandability
5. Tiny cost (2000 USD or so)
]

]

---
layout: false
.left-column[
  ## Multichannel Ephys
  ### Distributed systems (A/D, etc) 
  ### Intan Chips
  ### Open Ephys 
]
.right-column[

### Open Ephys 1.0: Regressions

.pull-right[
<img class="right" src="./fig/oe-summary.jpg" width="100%"/>
]

.pull-left[
1. Single Non selectable analog reference
    - Digital reference selection increases noise
2. Intan amplifiers are 
    - Nonlinear for high amplitude signals 
    - Considerable phase and amplitude distortion at low frequencies
]
]

---
layout: false
.left-column[
  ## Multichannel Ephys
  ### Distributed systems (A/D, etc) 
  ### Intan Chips
  ### Open Ephys 
]
.right-column[

### Open Ephys 1.0: Design Limitations

1. All logic is still localized at host computer
    - Headstage is "dumb"
2. Connectorization is reduced, but scales linearly with the number
  of devices on headstage
    - e.g. 8 extra wires/Intan chip
    - Commutation still relies on specilized devices
3. Hardware is not scalable, modular, or easily standardized
4. Although advertised for its closed-loop capabilites, the hardware has
  remarkable _bad_ closed loop performance (vs. MEABench)
]

---
layout: false
.left-column[
  ## Multichannel Ephys
  ### Distributed systems (A/D, etc) 
  ### Intan Chips
  ### Open Ephys 
]
.right-column[

### Open Ephys 1.0: Design Limitations

Closed loop performance is limited by USB bus

.pull-left[
MEABench, ~2004

<img class="right" src="./fig/meabench-loop-time.jpg" width="100%"/>
]

.pull-left[
Open Ephys, 2017

<img class="right" src="./fig/oe-loop-time.jpg" width="100%"/>
]

]

---
layout: false
.left-column[
  ## Open Ephys++
]
.right-column[

### Goals of OpenEphys++
1.  Scalable and modular design that allows increases in channel count and
    addition of future sensors with no increase in connectorization
2.  Reduce and stabilize closed-loop latency
3.  Commodity hardware and standard interfaces wherever possible
4.  Modular firmware that can be extended 
5.  Low-level API
    - Agnostic to language, OS, etc and 
    - Built to make high-level language bindings
    - Can be easily integrated into _existing_ acquisition software
]

---
layout: false
.left-column[
  ## Open Ephys++
]
.right-column[

### Scalibility
- PCIe bus
- On-headstage FPGA
- Data framing
- Frame serialization
- Coaxial transmission.red[<sup>1</sup>]

<img class="right" src="./fig/ulca-miniscope.jpg" width="40%"/>
]

.footnote[
  .red[1] miniscope.org; Nature volume 534, pages 115â€“118 
]

---
layout: false
.left-column[
  ## Open Ephys++
]
.right-column[

### Latency
- PCIe bus
- Up to 63 GB/second
- Negligable latency

<img class="right" src="./fig/round-trip-time.png" width="100%"/>
]

]

---
layout: false
.left-column[
  ## Open Ephys++
]
.right-column[

### Modularity
- Modular firmware allows mixing arbitrary remote sensors with different
sampling rates
- Data is serialized into frames which are transmitted over PCIe buse and
decoded by host API 

<img class="right" src="./fig/firmware.png" width="100%"/>
]

---
layout: false
.left-column[
  ## Open Ephys++
]
.right-column[

### `liboepcie`: Low-level API 
- ANSI C, no dependencies other than C standar library
- UNIX inspired
    - Simple
    - Consistent
    - Interoperable
]

---
layout: false
.left-column[
  ## Open Ephys++
]
.right-column[

### `liboepcie` 
```c
// Context
typedef struct oe_ctx_impl *oe_ctx;

// Context manipulation
oe_ctx oe_create_ctx();
int oe_init_ctx(oe_ctx ctx);
int oe_destroy_ctx(oe_ctx ctx);

// Option getting/setting
int oe_get_opt(const oe_ctx ctx, int option, void* value, size_t *size);
int oe_set_opt(oe_ctx ctx, int option, const void* value, size_t size);

// Hardware inspection, manipulation, and IO
int oe_read_reg(const oe_ctx ctx, size_t dev_idx, oe_reg_addr_t addr, oe_reg_val_t *value);
int oe_write_reg(const oe_ctx ctx, size_t dev_idx, oe_reg_addr_t addr, oe_reg_val_t value);
int oe_read_frame(const oe_ctx ctx, oe_frame_t **frame);
void oe_destroy_frame(oe_frame_t *frame);
//int oe_write(const oe_ctx ctx, void *data, size_t num_frames);

// Internal type conversion
void oe_version(int *major, int *minor, int *patch);
const char *oe_error_str(int err);
const char *oe_device_str(int dev_id);
```
]

---
template: inverse
##.lgray[Migrating to Open Ephys ++]

---
layout: false
.left-column[
  ## Migrating to Open Ephys++
  ### Stuff you need
]
.right-column[

1. Headstage
2. Coaxial cable
3. Commutator (optional)
4. Host board*
5. FMC cable*
6. KC705*
7. Acqusition Software
8. Plating board (optional; lab shared)
9. Test board (optional, but not really)

.footnote[
  Will likely be combined in future
]
]

---
layout: false
.left-column[
  ## Migrating to Open Ephys++
  ### Stuff you need
]
.right-column[
### Headstages

1. Rat rev 1.0 
    - Tested
    - 2 PCBs
    - Ephys only to 128 channels
2. Mouse rev 1.0
    - In testing, done in 1 month
    - Single PCB
        - 64 channels
        - Steam VR tracking, optogenetics, electrical stimulation, 9 DOF IMU
3. Rat rev 2.0
    - WIP
    - Single PCB
    - 128 or 256 channels
    - Steam VR tracking, optogenetics, electrical stimulation, wireless
    operationation, expanssion headers
]
    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>
    <script> 
        var hljs = remark.highlighter.engine; 
    </script>
    <script type="text/javascript">
        var slideshow = remark.create( {
          highlightLanguage: 'c',
            highlightStyle: 'monokai'});

      // Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
      });

      MathJax.Hub.Configured();
    </script>
  </body>
</html>
